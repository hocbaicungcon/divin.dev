I"7<ul>
  <li><a href="#state-management">State Management</a>
    <ul>
      <li><a href="#reactive-state-manager">Reactive State Manager</a>
        <ul>
          <li><a href="#advantages">Advantages</a></li>
          <li><a href="#maximum-performance">Maximum performance:</a></li>
          <li><a href="#declaring-a-reactive-variable">Declaring a reactive variable</a>
            <ul>
              <li><a href="#having-a-reactive-state-is-easy">Having a reactive state, is easy.</a></li>
            </ul>
          </li>
          <li><a href="#using-the-values-in-the-view">Using the values in the view</a></li>
          <li><a href="#conditions-to-rebuild">Conditions to rebuild</a></li>
          <li><a href="#where-obs-can-be-used">Where .obs can be used</a></li>
          <li><a href="#note-about-lists">Note about Lists</a></li>
          <li><a href="#why-i-have-to-use-value">Why i have to use .value</a></li>
          <li><a href="#obx">Obx()</a></li>
          <li><a href="#workers">Workers</a></li>
        </ul>
      </li>
      <li><a href="#simple-state-manager">Simple State Manager</a>
        <ul>
          <li><a href="#advantages-1">Advantages</a></li>
          <li><a href="#usage">Usage</a></li>
          <li><a href="#how-it-handles-controllers">How it handles controllers</a></li>
          <li><a href="#you-wont-need-statefulwidgets-anymore">You won’t need StatefulWidgets anymore</a></li>
          <li><a href="#why-it-exists">Why it exists</a></li>
          <li><a href="#other-ways-of-using-it">Other ways of using it</a></li>
          <li><a href="#unique-ids">Unique IDs</a></li>
        </ul>
      </li>
      <li><a href="#mixing-the-two-state-managers">Mixing the two state managers</a></li>
      <li><a href="#getbuilder-vs-getx-vs-obx-vs-mixinbuilder">GetBuilder vs GetX vs Obx vs MixinBuilder</a></li>
    </ul>
  </li>
</ul>

<h1 id="state-management">State Management</h1>

<p>GetX does not use Streams or ChangeNotifier like other state managers. Why? In addition to building applications for android, iOS, web, linux, macos and linux, with GetX you can build server applications with the same syntax as Flutter/GetX. In order to improve response time and reduce RAM consumption, we created GetValue and GetStream, which are low latency solutions that deliver a lot of performance, at a low operating cost. We use this base to build all of our resources, including state management.</p>

<ul>
  <li><em>Complexity</em>: Some state managers are complex and have a lot of boilerplate. With GetX you don’t have to define a class for each event, the code is highly clean and clear, and you do a lot more by writing less. Many people have given up on Flutter because of this topic, and they now finally have a stupidly simple solution for managing states.</li>
  <li><em>No code generators</em>: You spend half your development time writing your application logic. Some state managers rely on code generators to have minimally readable code. Changing a variable and having to run build_runner can be unproductive, and often the waiting time after a flutter clean will be long, and you will have to drink a lot of coffee.</li>
</ul>

<p>With GetX everything is reactive, and nothing depends on code generators, increasing your productivity in all aspects of your development.</p>

<ul>
  <li><em>It does not depend on context</em>: You probably already needed to send the context of your view to a controller, making the View’s coupling with your business logic high. You have probably had to use a dependency for a place that has no context, and had to pass the context through various classes and functions. This just doesn’t exist with GetX. You have access to your controllers from within your controllers without any context. You don’t need to send the context by parameter for literally nothing.</li>
  <li><em>Granular control</em>: most state managers are based on ChangeNotifier. ChangeNotifier will notify all widgets that depend on it when notifyListeners is called. If you have 40 widgets on one screen, which have a variable of your ChangeNotifier class, when you update one, all of them will be rebuilt.</li>
</ul>

<p>With GetX, even nested widgets are respected. If you have Obx watching your ListView, and another watching a checkbox inside the ListView, when changing the CheckBox value, only it will be updated, when changing the List value, only the ListView will be updated.</p>

<ul>
  <li><em>It only reconstructs if its variable REALLY changes</em>: GetX has flow control, that means if you display a Text with ‘Paola’, if you change the observable variable to ‘Paola’ again, the widget will not be reconstructed. That’s because GetX knows that ‘Paola’ is already being displayed in Text, and will not do unnecessary reconstructions.</li>
</ul>

<p>Most (if not all) current state managers will rebuild on the screen.</p>

<h2 id="reactive-state-manager">Reactive State Manager</h2>

<p>Reactive programming can alienate many people because it is said to be complicated. GetX turns reactive programming into something quite simple:</p>

<ul>
  <li>You won’t need to create StreamControllers.</li>
  <li>You won’t need to create a StreamBuilder for each variable</li>
  <li>You will not need to create a class for each state.</li>
  <li>You will not need to create a get for an initial value.</li>
</ul>

<p>Reactive programming with Get is as easy as using setState.</p>

<p>Let’s imagine that you have a name variable and want that every time you change it, all widgets that use it are automatically changed.</p>

<p>This is your count variable:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">name</span> <span class="o">=</span> <span class="s">'Jonatas Borges'</span><span class="o">;</span>
</code></pre></div></div>

<p>To make it observable, you just need to add “.obs” to the end of it:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">name</span> <span class="o">=</span> <span class="s">'Jonatas Borges'</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
</code></pre></div></div>

<p>That’s all. It’s <em>that</em> simple.</p>

<p>From now on, we might refer to this reactive-“.obs”(ervables) variables as <em>Rx</em>.</p>

<p>What did we do under the hood? We created a <code class="language-plaintext highlighter-rouge">Stream</code> of <code class="language-plaintext highlighter-rouge">String</code> s, assigned the initial value <code class="language-plaintext highlighter-rouge">"Jonatas Borges"</code> , we notified all widgets that use <code class="language-plaintext highlighter-rouge">"Jonatas Borges"</code> that they now “belong” to this variable, and when the <em>Rx</em> value changes, they will have to change as well.</p>

<p>This is the <strong>magic of GetX</strong>, thanks to Dart’s capabilities.</p>

<p>But, as we know, a <code class="language-plaintext highlighter-rouge">Widget</code> can only be changed if it is inside a function, because static classes do not have the power to “auto-change”.</p>

<p>You will need to create a <code class="language-plaintext highlighter-rouge">StreamBuilder</code> , subscribe to this variable to listen for changes, and create a “cascade” of nested <code class="language-plaintext highlighter-rouge">StreamBuilder</code> if you want to change several variables in the same scope, right?</p>

<p>No, you don’t need a <code class="language-plaintext highlighter-rouge">StreamBuilder</code> , but you are right about static classes.</p>

<p>Well, in the view, we usually have a lot of boilerplate when we want to change a specific Widget, that’s the Flutter way. 
With <strong>GetX</strong> you can also forget about this boilerplate code.</p>

<p><code class="language-plaintext highlighter-rouge">StreamBuilder( … )</code> ? <code class="language-plaintext highlighter-rouge">initialValue: …</code> ? <code class="language-plaintext highlighter-rouge">builder: …</code> ? Nope, you just need to place this variable inside an <code class="language-plaintext highlighter-rouge">Obx()</code> Widget.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Obx</span> <span class="o">(()</span> <span class="o">=&gt;</span> <span class="n">Text</span> <span class="o">(</span><span class="n">controller</span><span class="o">.</span><span class="na">name</span><span class="o">));</span>
</code></pre></div></div>

<p><em>What do you need to memorize?</em>  Only <code class="language-plaintext highlighter-rouge">Obx(() =&gt;</code> .</p>

<p>You are just passing that Widget through an arrow-function into an <code class="language-plaintext highlighter-rouge">Obx()</code> (the “Observer” of the <em>Rx</em>).</p>

<p><code class="language-plaintext highlighter-rouge">Obx</code> is pretty smart, and will only change if the value of <code class="language-plaintext highlighter-rouge">controller.name</code> changes.</p>

<p>If <code class="language-plaintext highlighter-rouge">name</code> is <code class="language-plaintext highlighter-rouge">"John"</code> , and you change it to <code class="language-plaintext highlighter-rouge">"John"</code> ( <code class="language-plaintext highlighter-rouge">name.value = "John"</code> ), as it’s the same <code class="language-plaintext highlighter-rouge">value</code> as before, nothing will change on the screen, and <code class="language-plaintext highlighter-rouge">Obx</code> , to save resources, will simply ignore the new value and not rebuild the Widget. <strong>Isn’t that amazing?</strong></p>

<blockquote>
  <p>So, what if I have 5 <em>Rx</em> (observable) variables within an <code class="language-plaintext highlighter-rouge">Obx</code> ?</p>
</blockquote>

<p>It will just update when <strong>any</strong> of them changes.</p>

<blockquote>
  <p>And if I have 30 variables in a class, when I update one, will it update <strong>all</strong> the variables that are in that class?</p>
</blockquote>

<p>Nope, just the <strong>specific Widget</strong> that uses that <em>Rx</em> variable.</p>

<p>So, <strong>GetX</strong> only updates the screen, when the <em>Rx</em> variable changes it’s value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
final isOpen = false.obs;

// NOTHING will happen... same value.
void onButtonTap() =&gt; isOpen.value=false;
</code></pre></div></div>

<h3 id="advantages">Advantages</h3>

<p><strong>GetX()</strong> helps you when you need <strong>granular</strong> control over what’s being updated.</p>

<p>If you do not need <code class="language-plaintext highlighter-rouge">unique IDs</code> , because all your variables will be modified when you perform an action, then use <code class="language-plaintext highlighter-rouge">GetBuilder</code> , 
because it’s a Simple State Updater (in blocks, like <code class="language-plaintext highlighter-rouge">setState()</code> ), made in just a few lines of code.
It was made simple, to have the least CPU impact, and just to fulfill a single purpose (a <em>State</em> rebuild) and spend the minimum resources possible.</p>

<p>If you need a <strong>powerful</strong> State Manager, you can’t go wrong with <strong>GetX</strong>.</p>

<p>It doesn’t work with variables, but <strong>flows</strong>, everything in it are <code class="language-plaintext highlighter-rouge">Streams</code> under the hood.</p>

<p>You can use <em>rxDart</em> in conjunction with it, because everything are <code class="language-plaintext highlighter-rouge">Streams</code>, 
you can listen to the <code class="language-plaintext highlighter-rouge">event</code> of each “<em>Rx</em> variable”, 
because everything in it are <code class="language-plaintext highlighter-rouge">Streams</code>.</p>

<p>It is literally a <em>BLoC</em> approach, easier than <em>MobX</em>, and without code generators or decorations.
You can turn <strong>anything</strong> into an <em>“Observable”</em> with just a <code class="language-plaintext highlighter-rouge">.obs</code> .</p>

<h3 id="maximum-performance">Maximum performance:</h3>

<p>In addition to having a smart algorithm for minimal rebuilds, <strong>GetX</strong> uses comparators 
to make sure the State has changed.</p>

<p>If you experience any errors in your app, and send a duplicate change of State, 
<strong>GetX</strong> will ensure it will not crash.</p>

<p>With <strong>GetX</strong> the State only changes if the <code class="language-plaintext highlighter-rouge">value</code> change. 
That’s the main difference between <strong>GetX</strong>, and using _ <code class="language-plaintext highlighter-rouge">computed</code> from MobX_. 
When joining two <strong>observables</strong>, and one changes; the listener of that <em>observable</em> will change as well.</p>

<p>With <strong>GetX</strong>, if you join two variables, <code class="language-plaintext highlighter-rouge">GetX()</code> (similar to <code class="language-plaintext highlighter-rouge">Observer()</code> ) will only rebuild if it implies a real change of State.</p>

<h3 id="declaring-a-reactive-variable">Declaring a reactive variable</h3>

<p>You have 3 ways to turn a variable into an “observable”.</p>

<p>1 - The first is using <strong><code class="language-plaintext highlighter-rouge">Rx{Type}</code></strong>.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// initial value is recommended, but not mandatory</span>
<span class="kd">final</span> <span class="n">name</span> <span class="o">=</span> <span class="n">RxString</span><span class="o">(</span><span class="s">''</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">isLogged</span> <span class="o">=</span> <span class="n">RxBool</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">count</span> <span class="o">=</span> <span class="n">RxInt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">RxDouble</span><span class="o">(</span><span class="mf">0.0</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">items</span> <span class="o">=</span> <span class="n">RxList</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;([]);</span>
<span class="kd">final</span> <span class="n">myMap</span> <span class="o">=</span> <span class="n">RxMap</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;({});</span>
</code></pre></div></div>

<p>2 - The second is to use <strong><code class="language-plaintext highlighter-rouge">Rx</code></strong> and use Darts Generics, <code class="language-plaintext highlighter-rouge">Rx&lt;Type&gt;</code></p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">name</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;(</span><span class="s">''</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">isLogged</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">Bool</span><span class="o">&gt;(</span><span class="kc">false</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">count</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="mf">0.0</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">number</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">Num</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">)</span>
<span class="kd">final</span> <span class="n">items</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;&gt;([]);</span>
<span class="kd">final</span> <span class="n">myMap</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;&gt;({});</span>

<span class="c1">// Custom classes - it can be any class, literally</span>
<span class="kd">final</span> <span class="n">user</span> <span class="o">=</span> <span class="n">Rx</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;();</span>
</code></pre></div></div>

<p>3 - The third, more practical, easier and preferred approach, just add <strong><code class="language-plaintext highlighter-rouge">.obs</code></strong> as a property of your <code class="language-plaintext highlighter-rouge">value</code> :</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">name</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">isLogged</span> <span class="o">=</span> <span class="kc">false</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">balance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">items</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;[].</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">myMap</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">String</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;{}.</span><span class="na">obs</span><span class="o">;</span>

<span class="c1">// Custom classes - it can be any class, literally</span>
<span class="kd">final</span> <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">().</span><span class="na">obs</span><span class="o">;</span>
</code></pre></div></div>

<h5 id="having-a-reactive-state-is-easy">Having a reactive state, is easy.</h5>

<p>As we know, <em>Dart</em> is now heading towards <em>null safety</em>.
To be prepared, from now on, you should always start your <em>Rx</em> variables with an <strong>initial value</strong>.</p>

<blockquote>
  <p>Transforming a variable into an <em>observable</em> + <em>initial value</em> with <strong>GetX</strong> is the simplest, and most practical approach.</p>
</blockquote>

<p>You will literally add a “ <code class="language-plaintext highlighter-rouge">.obs</code> “ to the end of your variable, and <strong>that’s it</strong>, you’ve made it observable, 
and its <code class="language-plaintext highlighter-rouge">.value</code> , well, will be the <em>initial value</em>).</p>

<h3 id="using-the-values-in-the-view">Using the values in the view</h3>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// controller file</span>
<span class="kd">final</span> <span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">count2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="kt">int</span> <span class="kd">get</span> <span class="n">sum</span> <span class="o">=&gt;</span> <span class="n">count1</span><span class="o">.</span><span class="na">value</span> <span class="o">+</span> <span class="n">count2</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// view file</span>
<span class="n">GetX</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">controller</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"count 1 rebuild"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Text</span><span class="o">(</span><span class="s">'</span><span class="si">${controller.count1.value}</span><span class="s">'</span><span class="o">);</span>
  <span class="o">},</span>
<span class="o">),</span>
<span class="n">GetX</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">controller</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"count 2 rebuild"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Text</span><span class="o">(</span><span class="s">'</span><span class="si">${controller.count2.value}</span><span class="s">'</span><span class="o">);</span>
  <span class="o">},</span>
<span class="o">),</span>
<span class="n">GetX</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">controller</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"count 3 rebuild"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Text</span><span class="o">(</span><span class="s">'</span><span class="si">${controller.sum}</span><span class="s">'</span><span class="o">);</span>
  <span class="o">},</span>
<span class="o">),</span>
</code></pre></div></div>

<p>If we increment <code class="language-plaintext highlighter-rouge">count1.value++</code> , it will print:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">count 1 rebuild</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">count 3 rebuild</code></p>
  </li>
</ul>

<p>because <code class="language-plaintext highlighter-rouge">count1</code> has a value of <code class="language-plaintext highlighter-rouge">1</code> , and <code class="language-plaintext highlighter-rouge">1 + 0 = 1</code> , changing the <code class="language-plaintext highlighter-rouge">sum</code> getter value.</p>

<p>If we change <code class="language-plaintext highlighter-rouge">count2.value++</code> , it will print:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">count 2 rebuild</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">count 3 rebuild</code></p>
  </li>
</ul>

<p>because <code class="language-plaintext highlighter-rouge">count2.value</code> changed, and the result of the <code class="language-plaintext highlighter-rouge">sum</code> is now <code class="language-plaintext highlighter-rouge">2</code> .</p>

<ul>
  <li>NOTE: By default, the very first event will rebuild the widget, even if it is the same <code class="language-plaintext highlighter-rouge">value</code>.</li>
</ul>

<p>This behavior exists due to Boolean variables.</p>

<p>Imagine you did this:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">isLogged</span> <span class="o">=</span> <span class="kc">false</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
</code></pre></div></div>

<p>And then, you checked if a user is “logged in” to trigger an event in <code class="language-plaintext highlighter-rouge">ever</code> .</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@override</span>
<span class="n">onInit</span><span class="o">(){</span>
  <span class="n">ever</span><span class="o">(</span><span class="n">isLogged</span><span class="o">,</span> <span class="n">fireRoute</span><span class="o">);</span>
  <span class="n">isLogged</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">await</span> <span class="n">Preferences</span><span class="o">.</span><span class="na">hasToken</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">fireRoute</span><span class="o">(</span><span class="n">logged</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">logged</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">Get</span><span class="o">.</span><span class="na">off</span><span class="o">(</span><span class="n">Home</span><span class="o">());</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="n">Get</span><span class="o">.</span><span class="na">off</span><span class="o">(</span><span class="n">Login</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>if <code class="language-plaintext highlighter-rouge">hasToken</code> was <code class="language-plaintext highlighter-rouge">false</code> , there would be no change to <code class="language-plaintext highlighter-rouge">isLogged</code> , so <code class="language-plaintext highlighter-rouge">ever()</code> would never be called.
To avoid this type of behavior, the first change to an <em>observable</em> will always trigger an event, 
even if it contains the same <code class="language-plaintext highlighter-rouge">.value</code> .</p>

<p>You can remove this behavior if you want, using:
 <code class="language-plaintext highlighter-rouge">isLogged.firstRebuild = false;</code></p>

<h3 id="conditions-to-rebuild">Conditions to rebuild</h3>

<p>In addition, Get provides refined state control. You can condition an event (such as adding an object to a list), on a certain condition.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// First parameter: condition, must return true or false.</span>
<span class="c1">// Second parameter: the new value to apply if the condition is true.</span>
<span class="n">list</span><span class="o">.</span><span class="na">addIf</span><span class="o">(</span><span class="n">item</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">,</span> <span class="n">item</span><span class="o">);</span>
</code></pre></div></div>

<p>Without decorations, without a code generator, without complications :smile:</p>

<p>Do you know Flutter’s counter app? Your Controller class might look like this:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CountController</span> <span class="kd">extends</span> <span class="n">GetxController</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>With a simple:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">controller</span><span class="o">.</span><span class="na">count</span><span class="o">.</span><span class="na">value</span><span class="o">++</span>
</code></pre></div></div>

<p>You could update the counter variable in your UI, regardless of where it is stored.</p>

<h3 id="where-obs-can-be-used">Where .obs can be used</h3>

<p>You can transform anything on obs. Here are two ways of doing it:</p>

<ul>
  <li>You can convert your class values to obs</li>
</ul>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RxUser</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Camila"</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="o">.</span><span class="na">obs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>or you can convert the entire class to be an observable</li>
</ul>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
  <span class="n">User</span><span class="o">({</span><span class="kt">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">});</span>
  <span class="kd">var</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">var</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// when instantianting:</span>
<span class="kd">final</span> <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">(</span><span class="nl">name:</span> <span class="s">"Camila"</span><span class="o">,</span> <span class="nl">age:</span> <span class="mi">18</span><span class="o">).</span><span class="na">obs</span><span class="o">;</span>
</code></pre></div></div>

<h3 id="note-about-lists">Note about Lists</h3>

<p>Lists are completely observable as are the objects within it. That way, if you add a value to a list, it will automatically rebuild the widgets that use it.</p>

<p>You also don’t need to use “.value” with lists, the amazing dart api allowed us to remove that.
Unfortunaly primitive types like String and int cannot be extended, making the use of .value mandatory, but that won’t be a problem if you work with gets and setters for these.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// On the controller</span>
<span class="kd">final</span> <span class="kt">String</span> <span class="n">title</span> <span class="o">=</span> <span class="s">'User Info:'</span><span class="o">.</span><span class="na">obs</span>
<span class="kd">final</span> <span class="n">list</span> <span class="o">=</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;().</span><span class="na">obs</span><span class="o">;</span>

<span class="c1">// on the view</span>
<span class="n">Text</span><span class="o">(</span><span class="n">controller</span><span class="o">.</span><span class="na">title</span><span class="o">.</span><span class="na">value</span><span class="o">),</span> <span class="c1">// String need to have .value in front of it</span>
<span class="n">ListView</span><span class="o">.</span><span class="na">builder</span> <span class="o">(</span>
  <span class="nl">itemCount:</span> <span class="n">controller</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">length</span> <span class="c1">// lists don't need it</span>
<span class="o">)</span>
</code></pre></div></div>

<p>When you are making your own classes observable, there is a different way to update them:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// on the model file</span>
<span class="c1">// we are going to make the entire class observable instead of each attribute</span>
<span class="kd">class</span> <span class="nf">User</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">User</span><span class="o">({</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">''</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">0</span><span class="o">});</span>
  <span class="kt">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// on the controller file</span>
<span class="kd">final</span> <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">().</span><span class="na">obs</span><span class="o">;</span>
<span class="c1">// when you need to update the user variable:</span>
<span class="n">user</span><span class="o">.</span><span class="na">update</span><span class="o">(</span> <span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// this parameter is the class itself that you want to update</span>
<span class="n">user</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">'Jonny'</span><span class="o">;</span>
<span class="n">user</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">18</span><span class="o">;</span>
<span class="o">});</span>
<span class="c1">// an alternative way of update the user variable:</span>
<span class="n">user</span><span class="o">(</span><span class="n">User</span><span class="o">(</span><span class="nl">name:</span> <span class="s">'João'</span><span class="o">,</span> <span class="nl">age:</span> <span class="mi">35</span><span class="o">));</span>

<span class="c1">// on view:</span>
<span class="n">Obx</span><span class="o">(()=&gt;</span> <span class="n">Text</span><span class="o">(</span><span class="s">"Name </span><span class="si">${user.value.name}</span><span class="s">: Age: </span><span class="si">${user.value.age}</span><span class="s">"</span><span class="o">))</span>
<span class="c1">// you can also access the model values without the .value:</span>
<span class="n">user</span><span class="o">().</span><span class="na">name</span><span class="o">;</span> <span class="c1">// notice that is the user variable, not the class (variable has lowercase u)</span>
</code></pre></div></div>

<p>You don’t have to work with sets if you don’t want to. you can use the “assign ‘and” assignAll “api.
The “assign” api will clear your list, and add a single object that you want to start there.
The “assignAll” api will clear the existing list and add any iterable objects that you inject into it.</p>

<h3 id="why-i-have-to-use-value">Why i have to use .value</h3>

<p>We could remove the obligation to use ‘value’ to <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">int</code> with a simple decoration and code generator, but the purpose of this library is precisely avoid external dependencies. We want to offer an environment ready for programming, involving the essentials (management of routes, dependencies and states), in a simple, lightweight and performant way, without a need of an external package.</p>

<p>You can literally add 3 letters to your pubspec (get) and a colon and start programming. All solutions included by default, from route management to state management, aim at ease, productivity and performance.</p>

<p>The total weight of this library is less than that of a single state manager, even though it is a complete solution, and that is what you must understand.</p>

<p>If you are bothered by <code class="language-plaintext highlighter-rouge">.value</code> , and like a code generator, MobX is a great alternative, and you can use it in conjunction with Get. For those who want to add a single dependency in pubspec and start programming without worrying about the version of a package being incompatible with another, or if the error of a state update is coming from the state manager or dependency, or still, do not want to worrying about the availability of controllers, whether literally “just programming”, get is just perfect.</p>

<p>If you have no problem with the MobX code generator, or have no problem with the BLoC boilerplate, you can simply use Get for routes, and forget that it has state manager. Get SEM and RSM were born out of necessity, my company had a project with more than 90 controllers, and the code generator simply took more than 30 minutes to complete its tasks after a Flutter Clean on a reasonably good machine, if your project it has 5, 10, 15 controllers, any state manager will supply you well. If you have an absurdly large project, and code generator is a problem for you, you have been awarded this solution.</p>

<p>Obviously, if someone wants to contribute to the project and create a code generator, or something similar, I will link in this readme as an alternative, my need is not the need for all devs, but for now I say, there are good solutions that already do that, like MobX.</p>

<h3 id="obx">Obx()</h3>

<p>Typing in Get using Bindings is unnecessary. you can use the Obx widget instead of GetX which only receives the anonymous function that creates a widget.
Obviously, if you don’t use a type, you will need to have an instance of your controller to use the variables, or use <code class="language-plaintext highlighter-rouge">Get.find&lt;Controller&gt;()</code> .value or Controller.to.value to retrieve the value.</p>

<h3 id="workers">Workers</h3>

<p>Workers will assist you, triggering specific callbacks when an event occurs.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Called every time `count1` changes.</span>
<span class="n">ever</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"</span><span class="si">$_</span><span class="s"> has been changed"</span><span class="o">));</span>

<span class="c1">/// Called only first time the variable $_ is changed</span>
<span class="n">once</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"</span><span class="si">$_</span><span class="s"> was changed once"</span><span class="o">));</span>

<span class="c1">/// Anti DDos - Called every time the user stops typing for 1 second, for example.</span>
<span class="n">debounce</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"debouce</span><span class="si">$_</span><span class="s">"</span><span class="o">),</span> <span class="nl">time:</span> <span class="n">Duration</span><span class="o">(</span><span class="nl">seconds:</span> <span class="mi">1</span><span class="o">));</span>

<span class="c1">/// Ignore all changes within 1 second.</span>
<span class="n">interval</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="s">"interval </span><span class="si">$_</span><span class="s">"</span><span class="o">),</span> <span class="nl">time:</span> <span class="n">Duration</span><span class="o">(</span><span class="nl">seconds:</span> <span class="mi">1</span><span class="o">));</span>
</code></pre></div></div>

<p>All workers (except <code class="language-plaintext highlighter-rouge">debounce</code> ) have a <code class="language-plaintext highlighter-rouge">condition</code> named parameter, which can be a <code class="language-plaintext highlighter-rouge">bool</code> or a callback that returns a <code class="language-plaintext highlighter-rouge">bool</code> .
This <code class="language-plaintext highlighter-rouge">condition</code> defines when the <code class="language-plaintext highlighter-rouge">callback</code> function executes.</p>

<p>All workers returns a <code class="language-plaintext highlighter-rouge">Worker</code> instance, that you can use to cancel ( via <code class="language-plaintext highlighter-rouge">dispose()</code> ) the worker.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ever</code></strong></li>
</ul>

<p>is called every time the <em>Rx</em> variable emits a new value.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">everAll</code></strong></li>
</ul>

<p>Much like <code class="language-plaintext highlighter-rouge">ever</code> , but it takes a <code class="language-plaintext highlighter-rouge">List</code> of <em>Rx</em> values Called every time its variable is changed. That’s it.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">once</code></strong></li>
</ul>

<p>‘once’ is called only the first time the variable has been changed.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">debounce</code></strong></li>
</ul>

<p>‘debounce’ is very useful in search functions, where you only want the API to be called when the user finishes typing. If the user types “Jonny”, you will have 5 searches in the APIs, by the letter J, o, n, n, and y. With Get this does not happen, because you will have a “debounce” Worker that will only be triggered at the end of typing.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">interval</code></strong></li>
</ul>

<p>‘interval’ is different from the debouce. debouce if the user makes 1000 changes to a variable within 1 second, he will send only the last one after the stipulated timer (the default is 800 milliseconds). Interval will instead ignore all user actions for the stipulated period. If you send events for 1 minute, 1000 per second, debounce will only send you the last one, when the user stops strafing events. interval will deliver events every second, and if set to 3 seconds, it will deliver 20 events that minute. This is recommended to avoid abuse, in functions where the user can quickly click on something and get some advantage (imagine that the user can earn coins by clicking on something, if he clicked 300 times in the same minute, he would have 300 coins, using interval, you you can set a time frame for 3 seconds, and even then clicking 300 or a thousand times, the maximum he would get in 1 minute would be 20 coins, clicking 300 or 1 million times). The debounce is suitable for anti-DDos, for functions like search where each change to onChange would cause a query to your api. Debounce will wait for the user to stop typing the name, to make the request. If it were used in the coin scenario mentioned above, the user would only win 1 coin, because it is only executed, when the user “pauses” for the established time.</p>

<ul>
  <li>NOTE: Workers should always be used when starting a Controller or Class, so it should always be on onInit (recommended), Class constructor, or the initState of a StatefulWidget (this practice is not recommended in most cases, but it shouldn’t have any side effects).</li>
</ul>

<h2 id="simple-state-manager">Simple State Manager</h2>

<p>Get has a state manager that is extremely light and easy, which does not use ChangeNotifier, will meet the need especially for those new to Flutter, and will not cause problems for large applications.</p>

<p>GetBuilder is aimed precisely at multiple state control. Imagine that you added 30 products to a cart, you click delete one, at the same time that the list is updated, the price is updated and the badge in the shopping cart is updated to a smaller number. This type of approach makes GetBuilder killer, because it groups states and changes them all at once without any “computational logic” for that. GetBuilder was created with this type of situation in mind, since for ephemeral change of state, you can use setState and you would not need a state manager for this.</p>

<p>That way, if you want an individual controller, you can assign IDs for that, or use GetX. This is up to you, remembering that the more “individual” widgets you have, the more the performance of GetX will stand out, while the performance of GetBuilder should be superior, when there is multiple change of state.</p>

<h3 id="advantages-1">Advantages</h3>

<ol>
  <li>
    <p>Update only the required widgets.</p>
  </li>
  <li>
    <p>Does not use changeNotifier, it is the state manager that uses less memory (close to 0mb).</p>
  </li>
  <li>
    <p>Forget StatefulWidget! With Get you will never need it. With the other state managers, you will probably have to use a StatefulWidget to get the instance of your Provider, BLoC, MobX Controller, etc. But have you ever stopped to think that your appBar, your scaffold, and most of the widgets that are in your class are stateless? So why save the state of an entire class, if you can only save the state of the Widget that is stateful? Get solves that, too. Create a Stateless class, make everything stateless. If you need to update a single component, wrap it with GetBuilder, and its state will be maintained.</p>
  </li>
  <li>
    <p>Organize your project for real! Controllers must not be in your UI, place your TextEditController, or any controller you use within your Controller class.</p>
  </li>
  <li>
    <p>Do you need to trigger an event to update a widget as soon as it is rendered? GetBuilder has the property “initState”, just like StatefulWidget, and you can call events from your controller, directly from it, no more events being placed in your initState.</p>
  </li>
  <li>
    <p>Do you need to trigger an action like closing streams, timers and etc? GetBuilder also has the dispose property, where you can call events as soon as that widget is destroyed.</p>
  </li>
  <li>
    <p>Use streams only if necessary. You can use your StreamControllers inside your controller normally, and use StreamBuilder also normally, but remember, a stream reasonably consumes memory, reactive programming is beautiful, but you shouldn’t abuse it. 30 streams open simultaneously can be worse than changeNotifier (and changeNotifier is very bad).</p>
  </li>
  <li>
    <p>Update widgets without spending ram for that. Get stores only the GetBuilder creator ID, and updates that GetBuilder when necessary. The memory consumption of the get ID storage in memory is very low even for thousands of GetBuilders. When you create a new GetBuilder, you are actually sharing the state of GetBuilder that has a creator ID. A new state is not created for each GetBuilder, which saves A LOT OF ram for large applications. Basically your application will be entirely Stateless, and the few Widgets that will be Stateful (within GetBuilder) will have a single state, and therefore updating one will update them all. The state is just one.</p>
  </li>
  <li>
    <p>Get is omniscient and in most cases it knows exactly the time to take a controller out of memory. You should not worry about when to dispose of a controller, Get knows the best time to do this.</p>
  </li>
</ol>

<h3 id="usage">Usage</h3>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create controller class and extends GetxController</span>
<span class="kd">class</span> <span class="nc">Controller</span> <span class="kd">extends</span> <span class="n">GetxController</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">void</span> <span class="n">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">counter</span><span class="o">++;</span>
    <span class="n">update</span><span class="o">();</span> <span class="c1">// use update() to update counter variable on UI when increment be called</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// On your Stateless/Stateful class, use GetBuilder to update Text when increment be called</span>
<span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">init:</span> <span class="n">Controller</span><span class="o">(),</span> <span class="c1">// INIT IT ONLY THE FIRST TIME</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span>
    <span class="s">'</span><span class="si">${_.counter}</span><span class="s">'</span><span class="o">,</span>
  <span class="o">),</span>
<span class="o">)</span>
<span class="c1">//Initialize your controller only the first time. The second time you are using ReBuilder for the same controller, do not use it again. Your controller will be automatically removed from memory as soon as the widget that marked it as 'init' is deployed. You don't have to worry about that, Get will do it automatically, just make sure you don't start the same controller twice.</span>
</code></pre></div></div>

<p><strong>Done!</strong></p>

<ul>
  <li>
    <p>You have already learned how to manage states with Get.</p>
  </li>
  <li>
    <p>Note: You may want a larger organization, and not use the init property. For that, you can create a class and extends Bindings class, and within it mention the controllers that will be created within that route. Controllers will not be created at that time, on the contrary, this is just a statement, so that the first time you use a Controller, Get will know where to look. Get will remain lazyLoad, and will continue to dispose Controllers when they are no longer needed. See the pub.dev example to see how it works.</p>
  </li>
</ul>

<p>If you navigate many routes and need data that was in your previously used controller, you just need to use GetBuilder Again (with no init):</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OtherClass</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Scaffold</span><span class="o">(</span>
      <span class="nl">body:</span> <span class="n">Center</span><span class="o">(</span>
        <span class="nl">child:</span> <span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
          <span class="nl">builder:</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span><span class="s">'</span><span class="si">${s.counter}</span><span class="s">'</span><span class="o">),</span>
        <span class="o">),</span>
      <span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>

</code></pre></div></div>

<p>If you need to use your controller in many other places, and outside of GetBuilder, just create a get in your controller and have it easily. (or use <code class="language-plaintext highlighter-rouge">Get.find&lt;Controller&gt;()</code> )</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Controller</span> <span class="kd">extends</span> <span class="n">GetxController</span> <span class="o">{</span>

  <span class="c1">/// You do not need that. I recommend using it just for ease of syntax.</span>
  <span class="c1">/// with static method: Controller.to.counter();</span>
  <span class="c1">/// with no static method: Get.find&lt;Controller&gt;().counter();</span>
  <span class="c1">/// There is no difference in performance, nor any side effect of using either syntax. Only one does not need the type, and the other the IDE will autocomplete it.</span>
  <span class="kd">static</span> <span class="n">Controller</span> <span class="kd">get</span> <span class="n">to</span> <span class="o">=&gt;</span> <span class="n">Get</span><span class="o">.</span><span class="na">find</span><span class="o">();</span> <span class="c1">// add this line</span>

  <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">void</span> <span class="n">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">counter</span><span class="o">++;</span>
    <span class="n">update</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And then you can access your controller directly, that way:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FloatingActionButton</span><span class="o">(</span>
  <span class="nl">onPressed:</span> <span class="o">()</span> <span class="o">{</span>
    <span class="n">Controller</span><span class="o">.</span><span class="na">to</span><span class="o">.</span><span class="na">increment</span><span class="o">(),</span>
  <span class="o">}</span> <span class="c1">// This is incredibly simple!</span>
  <span class="nl">child:</span> <span class="n">Text</span><span class="o">(</span><span class="s">"</span><span class="si">${Controller.to.counter}</span><span class="s">"</span><span class="o">),</span>
<span class="o">),</span>
</code></pre></div></div>

<p>When you press FloatingActionButton, all widgets that are listening to the ‘counter’ variable will be updated automatically.</p>

<h3 id="how-it-handles-controllers">How it handles controllers</h3>

<p>Let’s say we have this:</p>

<p><code class="language-plaintext highlighter-rouge">Class a =&gt; Class B (has controller X) =&gt; Class C (has controller X)</code></p>

<p>In class A the controller is not yet in memory, because you have not used it yet (Get is lazyLoad). In class B you used the controller, and it entered memory. In class C you used the same controller as in class B, Get will share the state of controller B with controller C, and the same controller is still in memory. If you close screen C and screen B, Get will automatically take controller X out of memory and free up resources, because Class a is not using the controller. If you navigate to B again, controller X will enter memory again, if instead of going to class C, you return to class A again, Get will take the controller out of memory in the same way. If class C didn’t use the controller, and you took class B out of memory, no class would be using controller X and likewise it would be disposed of. The only exception that can mess with Get, is if you remove B from the route unexpectedly, and try to use the controller in C. In this case, the creator ID of the controller that was in B was deleted, and Get was programmed to remove it from memory every controller that has no creator ID. If you intend to do this, add the “autoRemove: false” flag to class B’s GetBuilder and use adoptID = true; in class C’s GetBuilder.</p>

<h3 id="you-wont-need-statefulwidgets-anymore">You won’t need StatefulWidgets anymore</h3>

<p>Using StatefulWidgets means storing the state of entire screens unnecessarily, even because if you need to minimally rebuild a widget, you will embed it in a Consumer/Observer/BlocProvider/GetBuilder/GetX/Obx, which will be another StatefulWidget.
The StatefulWidget class is a class larger than StatelessWidget, which will allocate more RAM, and this may not make a significant difference between one or two classes, but it will most certainly do when you have 100 of them!
Unless you need to use a mixin, like TickerProviderStateMixin, it will be totally unnecessary to use a StatefulWidget with Get.</p>

<p>You can call all methods of a StatefulWidget directly from a GetBuilder.
If you need to call initState() or dispose() method for example, you can call them directly;</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">initState:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Controller</span><span class="o">.</span><span class="na">to</span><span class="o">.</span><span class="na">fetchApi</span><span class="o">(),</span>
  <span class="nl">dispose:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Controller</span><span class="o">.</span><span class="na">to</span><span class="o">.</span><span class="na">closeStreams</span><span class="o">(),</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span><span class="s">'</span><span class="si">${s.username}</span><span class="s">'</span><span class="o">),</span>
<span class="o">),</span>
</code></pre></div></div>

<p>A much better approach than this is to use the onInit() and onClose() method directly from your controller.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@override</span>
<span class="kt">void</span> <span class="nf">onInit</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">fetchApi</span><span class="o">();</span>
  <span class="k">super</span><span class="o">.</span><span class="na">onInit</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>NOTE: If you want to start a method at the moment the controller is called for the first time, you DON’T NEED to use constructors for this, in fact, using a performance-oriented package like Get, this borders on bad practice, because it deviates from the logic in which the controllers are created or allocated (if you create an instance of this controller, the constructor will be called immediately, you will be populating a controller before it is even used, you are allocating memory without it being in use, this definitely hurts the principles of this library). The onInit() methods; and onClose(); were created for this, they will be called when the Controller is created, or used for the first time, depending on whether you are using Get.lazyPut or not. If you want, for example, to make a call to your API to populate data, you can forget about the old-fashioned method of initState/dispose, just start your call to the api in onInit, and if you need to execute any command like closing streams, use the onClose() for that.</li>
</ul>

<h3 id="why-it-exists">Why it exists</h3>

<p>The purpose of this package is precisely to give you a complete solution for navigation of routes, management of dependencies and states, using the least possible dependencies, with a high degree of decoupling. Get engages all high and low level Flutter APIs within itself, to ensure that you work with the least possible coupling. We centralize everything in a single package, to ensure that you don’t have any kind of coupling in your project. That way, you can put only widgets in your view, and leave the part of your team that works with the business logic free, to work with the business logic without depending on any element of the View. This provides a much cleaner working environment, so that part of your team works only with widgets, without worrying about sending data to your controller, and part of your team works only with the business logic in its breadth, without depending on no element of the view.</p>

<p>So to simplify this:
You don’t need to call methods in initState and send them by parameter to your controller, nor use your controller constructor for that, you have the onInit() method that is called at the right time for you to start your services.
You do not need to call the device, you have the onClose() method that will be called at the exact moment when your controller is no longer needed and will be removed from memory. That way, leave views for widgets only, refrain from any kind of business logic from it.</p>

<p>Do not call a dispose method inside GetxController, it will not do anything, remember that the controller is not a Widget, you should not “dispose” it, and it will be automatically and intelligently removed from memory by Get. If you used any stream on it and want to close it, just insert it into the close method. Example:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Controller</span> <span class="kd">extends</span> <span class="n">GetxController</span> <span class="o">{</span>
  <span class="n">StreamController</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">StreamController</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;();</span>
  <span class="n">StreamController</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="n">StreamController</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;();</span>

  <span class="c1">/// close stream = onClose method, not dispose.</span>
  <span class="nd">@override</span>
  <span class="kt">void</span> <span class="n">onClose</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">user</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">name</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="k">super</span><span class="o">.</span><span class="na">onClose</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Controller life cycle:</p>

<ul>
  <li>onInit() where it is created.</li>
  <li>onClose() where it is closed to make any changes in preparation for the delete method</li>
  <li>deleted: you do not have access to this API because it is literally removing the controller from memory. It is literally deleted, without leaving any trace.</li>
</ul>

<h3 id="other-ways-of-using-it">Other ways of using it</h3>

<p>You can use Controller instance directly on GetBuilder value:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">init:</span> <span class="n">Controller</span><span class="o">(),</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span>
    <span class="s">'</span><span class="si">${value.counter}</span><span class="s">'</span><span class="o">,</span> <span class="c1">//here</span>
  <span class="o">),</span>
<span class="o">),</span>
</code></pre></div></div>

<p>You may also need an instance of your controller outside of your GetBuilder, and you can use these approaches to achieve this:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Controller</span> <span class="kd">extends</span> <span class="n">GetxController</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="n">Controller</span> <span class="kd">get</span> <span class="n">to</span> <span class="o">=&gt;</span> <span class="n">Get</span><span class="o">.</span><span class="na">find</span><span class="o">();</span>
<span class="o">[...]</span>
<span class="o">}</span>
<span class="c1">// on you view:</span>
<span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>  
  <span class="nl">init:</span> <span class="n">Controller</span><span class="o">(),</span> <span class="c1">// use it only first time on each controller</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span>
    <span class="s">'</span><span class="si">${Controller.to.counter}</span><span class="s">'</span><span class="o">,</span> <span class="c1">//here</span>
  <span class="o">)</span>
<span class="o">),</span>
</code></pre></div></div>

<p>or</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Controller</span> <span class="kd">extends</span> <span class="n">GetxController</span> <span class="o">{</span>
 <span class="c1">// static Controller get to =&gt; Get.find(); // with no static get</span>
<span class="o">[...]</span>
<span class="o">}</span>
<span class="c1">// on stateful/stateless class</span>
<span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>  
  <span class="nl">init:</span> <span class="n">Controller</span><span class="o">(),</span> <span class="c1">// use it only first time on each controller</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span>
    <span class="s">'</span><span class="si">${Get.find&lt;Controller&gt;().counter}</span><span class="s">'</span><span class="o">,</span> <span class="c1">//here</span>
  <span class="o">),</span>
<span class="o">),</span>
</code></pre></div></div>

<ul>
  <li>You can use “non-canonical” approaches to do this. If you are using some other dependency manager, like get_it, modular, etc., and just want to deliver the controller instance, you can do this:</li>
</ul>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Controller</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">Controller</span><span class="o">();</span>
<span class="o">[...]</span>
<span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">init:</span> <span class="n">controller</span><span class="o">,</span> <span class="c1">//here</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span>
    <span class="s">'</span><span class="si">${controller.counter}</span><span class="s">'</span><span class="o">,</span> <span class="c1">// here</span>
  <span class="o">),</span>
<span class="o">),</span>

</code></pre></div></div>

<h3 id="unique-ids">Unique IDs</h3>

<p>If you want to refine a widget’s update control with GetBuilder, you can assign them unique IDs:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GetBuilder</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;(</span>
  <span class="nl">id:</span> <span class="s">'text'</span>
  <span class="nl">init:</span> <span class="n">Controller</span><span class="o">(),</span> <span class="c1">// use it only first time on each controller</span>
  <span class="nl">builder:</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">(</span>
    <span class="s">'</span><span class="si">${Get.find&lt;Controller&gt;().counter}</span><span class="s">'</span><span class="o">,</span> <span class="c1">//here</span>
  <span class="o">),</span>
<span class="o">),</span>
</code></pre></div></div>

<p>And update it this form:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span><span class="o">([</span><span class="s">'text'</span><span class="o">]);</span>
</code></pre></div></div>

<p>You can also impose conditions for the update:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span><span class="o">([</span><span class="s">'text'</span><span class="o">],</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p>GetX does this automatically and only reconstructs the widget that uses the exact variable that was changed, if you change a variable to the same as the previous one and that does not imply a change of state , GetX will not rebuild the widget to save memory and CPU cycles (3 is being displayed on the screen, and you change the variable to 3 again. In most state managers, this will cause a new rebuild, but with GetX the widget will only is rebuilt again, if in fact his state has changed).</p>

<h2 id="mixing-the-two-state-managers">Mixing the two state managers</h2>

<p>Some people opened a feature request, as they wanted to use only one type of reactive variable, and the other mechanics, and needed to insert an Obx into a GetBuilder for this. Thinking about it MixinBuilder was created. It allows both reactive changes by changing “.obs” variables, and mechanical updates via update(). However, of the 4 widgets he is the one that consumes the most resources, since in addition to having a Subscription to receive change events from his children, he subscribes to the update method of his controller.</p>

<p>Extending GetxController is important, as they have life cycles, and can “start” and “end” events in their onInit() and onClose() methods. You can use any class for this, but I strongly recommend you use the GetxController class to place your variables, whether they are observable or not.</p>

<h2 id="statemixin">StateMixin</h2>

<p>Another way to handle your <code class="language-plaintext highlighter-rouge">UI</code> state is use the <code class="language-plaintext highlighter-rouge">StateMixin&lt;T&gt;</code> .
To implement it, use the <code class="language-plaintext highlighter-rouge">with</code> to add the <code class="language-plaintext highlighter-rouge">StateMixin&lt;T&gt;</code>
to your controller which allows a T model.</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Controller</span> <span class="kd">extends</span> <span class="n">GetController</span> <span class="k">with</span> <span class="n">StateMixin</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;{}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">change()</code> method change the State whenever we want.
Just pass the data and the status in this way:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">change</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nl">status:</span> <span class="n">RxStatus</span><span class="o">.</span><span class="na">success</span><span class="o">());</span>
</code></pre></div></div>

<p>RxStatus allow these status:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RxStatus</span><span class="o">.</span><span class="na">loading</span><span class="o">();</span>
<span class="n">RxStatus</span><span class="o">.</span><span class="na">success</span><span class="o">();</span>
<span class="n">RxStatus</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
<span class="n">RxStatus</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">'message'</span><span class="o">);</span>
</code></pre></div></div>

<p>To represent it in the UI, use:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OtherClass</span> <span class="kd">extends</span> <span class="n">GetView</span><span class="o">&lt;</span><span class="n">Controller</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Scaffold</span><span class="o">(</span>

      <span class="nl">body:</span> <span class="n">controller</span><span class="o">.</span><span class="na">obx</span><span class="o">(</span>
        <span class="o">(</span><span class="n">state</span><span class="o">)=&gt;</span><span class="n">Text</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">name</span><span class="o">),</span>
        
        <span class="c1">// here you can put your custom loading indicator, but</span>
        <span class="c1">// by default would be Center(child:CircularProgressIndicator())</span>
        <span class="nl">onLoading:</span> <span class="n">CustomLoadingIndicator</span><span class="o">(),</span>
        <span class="nl">onEmpty:</span> <span class="n">Text</span><span class="o">(</span><span class="s">'No data found'</span><span class="o">),</span>

        <span class="c1">// here also you can set your own error widget, but by</span>
        <span class="c1">// default will be an Center(child:Text(error))</span>
        <span class="nl">onError:</span> <span class="o">(</span><span class="n">error</span><span class="o">)=&gt;</span><span class="n">Text</span><span class="o">(</span><span class="n">error</span><span class="o">),</span>
      <span class="o">),</span>
    <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="getbuilder-vs-getx-vs-obx-vs-mixinbuilder">GetBuilder vs GetX vs Obx vs MixinBuilder</h2>

<p>In a decade working with programming I was able to learn some valuable lessons.</p>

<p>My first contact with reactive programming was so “wow, this is incredible” and in fact reactive programming is incredible.
However, it is not suitable for all situations. Often all you need is to change the state of 2 or 3 widgets at the same time, or an ephemeral change of state, in which case reactive programming is not bad, but it is not appropriate.</p>

<p>Reactive programming has a higher consumption of RAM consumption that can be compensated for by the individual workflow, which will ensure that only one widget is rebuilt and when necessary, but creating a list with 80 objects, each with several streams is not a good one idea. Open the dart inspect and check how much a StreamBuilder consumes, and you’ll understand what I’m trying to tell you.</p>

<p>With that in mind, I created the simple state manager. It is simple, and that is exactly what you should demand from it: updating state in blocks in a simple way, and in the most economical way.</p>

<p>GetBuilder is very economical in RAM, and there is hardly a more economical approach than him (at least I can’t imagine one, if it exists, please let us know).</p>

<p>However, GetBuilder is still a mechanical state manager, you need to call update() just like you would need to call Provider’s notifyListeners().</p>

<p>There are other situations where reactive programming is really interesting, and not working with it is the same as reinventing the wheel. With that in mind, GetX was created to provide everything that is most modern and advanced in a state manager. It updates only what is necessary and when necessary, if you have an error and send 300 state changes simultaneously, GetX will filter and update the screen only if the state actually changes.</p>

<p>GetX is still more economical than any other reactive state manager, but it consumes a little more RAM than GetBuilder. Thinking about it and aiming to maximize the consumption of resources that Obx was created. Unlike GetX and GetBuilder, you will not be able to initialize a controller inside an Obx, it is just a Widget with a StreamSubscription that receives change events from your children, that’s all. It is more economical than GetX, but loses to GetBuilder, which was to be expected, since it is reactive, and GetBuilder has the most simplistic approach that exists, of storing a widget’s hashcode and its StateSetter. With Obx you don’t need to write your controller type, and you can hear the change from multiple different controllers, but it needs to be initialized before, either using the example approach at the beginning of this readme, or using the Bindings class.</p>
:ET